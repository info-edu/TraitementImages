

<!DOCTYPE html>
<html class="writer-html5" lang="fr" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Application aux sciences de la vie &mdash; Documentation TraitementImages 1.0</title>
  

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/translations.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Recherche" href="../search.html" />
    <link rel="prev" title="Histoire de bugs" href="HistoireDeBugs.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> TraitementImages
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Rechercher docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../notebooks.html">Python notebooks</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../sequence.html">Séquence d’activités</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="0_MonPremierNotebook.html">Mon premier notebook</a></li>
<li class="toctree-l2"><a class="reference internal" href="1_Images.html">Introduction aux images</a></li>
<li class="toctree-l2"><a class="reference internal" href="HistoireDeBugs.html">Histoire de bugs</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Application aux sciences de la vie</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Objectifs-et-durée">Objectifs et durée</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Problème:-Compter-les-cellules">Problème: Compter les cellules</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Stratégie:-lire,-segmenter,-filtrage,-grouper,-compter">Stratégie: lire, segmenter, filtrage, grouper, compter</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#Lire">Lire</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Segmenter">Segmenter</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Filtrage">Filtrage</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Grouper">Grouper</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Compter">Compter</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#Elements-connectés---version-avancée">Elements connectés - version avancée</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Alternatives">Alternatives</a></li>
</ul>
</li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">TraitementImages</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS for nbsphinx extension */

/* remove conflicting styling from Sphinx themes */
div.nbinput.container div.prompt *,
div.nboutput.container div.prompt *,
div.nbinput.container div.input_area pre,
div.nboutput.container div.output_area pre,
div.nbinput.container div.input_area .highlight,
div.nboutput.container div.output_area .highlight {
    border: none;
    padding: 0;
    margin: 0;
    box-shadow: none;
}

div.nbinput.container > div[class*=highlight],
div.nboutput.container > div[class*=highlight] {
    margin: 0;
}

div.nbinput.container div.prompt *,
div.nboutput.container div.prompt * {
    background: none;
}

div.nboutput.container div.output_area .highlight,
div.nboutput.container div.output_area pre {
    background: unset;
}

div.nboutput.container div.output_area div.highlight {
    color: unset;  /* override Pygments text color */
}

/* avoid gaps between output lines */
div.nboutput.container div[class*=highlight] pre {
    line-height: normal;
}

/* input/output containers */
div.nbinput.container,
div.nboutput.container {
    display: -webkit-flex;
    display: flex;
    align-items: flex-start;
    margin: 0;
    width: 100%;
}
@media (max-width: 540px) {
    div.nbinput.container,
    div.nboutput.container {
        flex-direction: column;
    }
}

/* input container */
div.nbinput.container {
    padding-top: 5px;
}

/* last container */
div.nblast.container {
    padding-bottom: 5px;
}

/* input prompt */
div.nbinput.container div.prompt pre {
    color: #307FC1;
}

/* output prompt */
div.nboutput.container div.prompt pre {
    color: #BF5B3D;
}

/* all prompts */
div.nbinput.container div.prompt,
div.nboutput.container div.prompt {
    width: 4.5ex;
    padding-top: 5px;
    position: relative;
    user-select: none;
}

div.nbinput.container div.prompt > div,
div.nboutput.container div.prompt > div {
    position: absolute;
    right: 0;
    margin-right: 0.3ex;
}

@media (max-width: 540px) {
    div.nbinput.container div.prompt,
    div.nboutput.container div.prompt {
        width: unset;
        text-align: left;
        padding: 0.4em;
    }
    div.nboutput.container div.prompt.empty {
        padding: 0;
    }

    div.nbinput.container div.prompt > div,
    div.nboutput.container div.prompt > div {
        position: unset;
    }
}

/* disable scrollbars on prompts */
div.nbinput.container div.prompt pre,
div.nboutput.container div.prompt pre {
    overflow: hidden;
}

/* input/output area */
div.nbinput.container div.input_area,
div.nboutput.container div.output_area {
    -webkit-flex: 1;
    flex: 1;
    overflow: auto;
}
@media (max-width: 540px) {
    div.nbinput.container div.input_area,
    div.nboutput.container div.output_area {
        width: 100%;
    }
}

/* input area */
div.nbinput.container div.input_area {
    border: 1px solid #e0e0e0;
    border-radius: 2px;
    /*background: #f5f5f5;*/
}

/* override MathJax center alignment in output cells */
div.nboutput.container div[class*=MathJax] {
    text-align: left !important;
}

/* override sphinx.ext.imgmath center alignment in output cells */
div.nboutput.container div.math p {
    text-align: left;
}

/* standard error */
div.nboutput.container div.output_area.stderr {
    background: #fdd;
}

/* ANSI colors */
.ansi-black-fg { color: #3E424D; }
.ansi-black-bg { background-color: #3E424D; }
.ansi-black-intense-fg { color: #282C36; }
.ansi-black-intense-bg { background-color: #282C36; }
.ansi-red-fg { color: #E75C58; }
.ansi-red-bg { background-color: #E75C58; }
.ansi-red-intense-fg { color: #B22B31; }
.ansi-red-intense-bg { background-color: #B22B31; }
.ansi-green-fg { color: #00A250; }
.ansi-green-bg { background-color: #00A250; }
.ansi-green-intense-fg { color: #007427; }
.ansi-green-intense-bg { background-color: #007427; }
.ansi-yellow-fg { color: #DDB62B; }
.ansi-yellow-bg { background-color: #DDB62B; }
.ansi-yellow-intense-fg { color: #B27D12; }
.ansi-yellow-intense-bg { background-color: #B27D12; }
.ansi-blue-fg { color: #208FFB; }
.ansi-blue-bg { background-color: #208FFB; }
.ansi-blue-intense-fg { color: #0065CA; }
.ansi-blue-intense-bg { background-color: #0065CA; }
.ansi-magenta-fg { color: #D160C4; }
.ansi-magenta-bg { background-color: #D160C4; }
.ansi-magenta-intense-fg { color: #A03196; }
.ansi-magenta-intense-bg { background-color: #A03196; }
.ansi-cyan-fg { color: #60C6C8; }
.ansi-cyan-bg { background-color: #60C6C8; }
.ansi-cyan-intense-fg { color: #258F8F; }
.ansi-cyan-intense-bg { background-color: #258F8F; }
.ansi-white-fg { color: #C5C1B4; }
.ansi-white-bg { background-color: #C5C1B4; }
.ansi-white-intense-fg { color: #A1A6B2; }
.ansi-white-intense-bg { background-color: #A1A6B2; }

.ansi-default-inverse-fg { color: #FFFFFF; }
.ansi-default-inverse-bg { background-color: #000000; }

.ansi-bold { font-weight: bold; }
.ansi-underline { text-decoration: underline; }


div.nbinput.container div.input_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight].math,
div.nboutput.container div.output_area.rendered_html,
div.nboutput.container div.output_area > div.output_javascript,
div.nboutput.container div.output_area:not(.rendered_html) > img{
    padding: 5px;
    margin: 0;
}

/* fix copybtn overflow problem in chromium (needed for 'sphinx_copybutton') */
div.nbinput.container div.input_area > div[class^='highlight'],
div.nboutput.container div.output_area > div[class^='highlight']{
    overflow-y: hidden;
}

/* hide copybtn icon on prompts (needed for 'sphinx_copybutton') */
.prompt a.copybtn {
    display: none;
}

/* Some additional styling taken form the Jupyter notebook CSS */
div.rendered_html table {
  border: none;
  border-collapse: collapse;
  border-spacing: 0;
  color: black;
  font-size: 12px;
  table-layout: fixed;
}
div.rendered_html thead {
  border-bottom: 1px solid black;
  vertical-align: bottom;
}
div.rendered_html tr,
div.rendered_html th,
div.rendered_html td {
  text-align: right;
  vertical-align: middle;
  padding: 0.5em 0.5em;
  line-height: normal;
  white-space: normal;
  max-width: none;
  border: none;
}
div.rendered_html th {
  font-weight: bold;
}
div.rendered_html tbody tr:nth-child(odd) {
  background: #f5f5f5;
}
div.rendered_html tbody tr:hover {
  background: rgba(66, 165, 245, 0.2);
}

/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<p>Lancer la version interactive sur : <a class="reference external" href="https://mybinder.org/v2/gh/info-edu/TraitementImages/gh-pages?filepath=notebooks/2_Cellules.ipynb"><img alt="binderlink" src="https://mybinder.org/badge_logo.svg" /></a> <a class="reference external" href="https://colab.research.google.com/github/info-edu/TraitementImages/blob/gh-pages/notebooks/2_Cellules.ipynb"><img alt="colablink" src="https://colab.research.google.com/assets/colab-badge.svg" /></a></p>
<hr class="docutils" />
<div class="section" id="Application-aux-sciences-de-la-vie">
<h1>Application aux sciences de la vie<a class="headerlink" href="#Application-aux-sciences-de-la-vie" title="Lien permanent vers ce titre">¶</a></h1>
<div class="section" id="Objectifs-et-durée">
<h2>Objectifs et durée<a class="headerlink" href="#Objectifs-et-durée" title="Lien permanent vers ce titre">¶</a></h2>
<p>Cette séquence a pour objectif de consolider les connaissances en manipulation d’images, de pratiquer les outils algorithmiques standards, de découvrir le domaine du traitement du signal et d’explorer la notion de complexité algorithmique. Il faudra compter une douzaine de période pour la réaliser.</p>
</div>
<div class="section" id="Problème:-Compter-les-cellules">
<h2>Problème: Compter les cellules<a class="headerlink" href="#Problème:-Compter-les-cellules" title="Lien permanent vers ce titre">¶</a></h2>
<p>Le traitement des images est beaucoup utilisé dans le domaine médical. Dans cette activité nous allons nous mettre dans la peau d’un chercheur en sciences de la vie et découvrir le type de problème que nous pourrions renncontrer: nnous obtenons des images de cellules de notre microscope, similaire à celle ci-dessous, et pour faire avancer notre recherche nous devons trouver un moyen efficace pour compter les cellules présentes dans chaque image.</p>
<p><img alt="image_cells" src="../_images/cells.png" /></p>
<p>Pour résoudre ce problème nous allons bien sur uttiliser nos connaissances sur la manipulation d’images. Nous allons réutiliser les libraries préccédentes et nous en rajouterons juste une, imageio, pour lire un fichier image standard.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span>import numpy as np # Pour manipuler des tableaux de nombres
import matplotlib.pyplot as plt # pour afficher des images
import imageio # pour lire notre photo
</pre></div>
</div>
</div>
<p>Commençons d’abord par vérifier que nous sommes bien en mesure de lire une de nos images et de la récupérer sous format numérique.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span>img_cells = imageio.imread(&#39;https://raw.githubusercontent.com/info-edu/Data/main/images/cells.png&#39;)
print(type(img_cells))
print(img_cells.shape)
plt.imshow(img_cells)
plt.show()
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
&lt;class &#39;imageio.core.util.Array&#39;&gt;
(326, 500, 4)
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_2_Cellules_4_1.png" src="../_images/notebooks_2_Cellules_4_1.png" />
</div>
</div>
<p>L’image a un type différent de numpy.ndarray, mais comme on peut le voir, c’est aussi un tableau avec des méthodes similaires à celles de numpy. Il y a par contre une différence majeure par rapport aux images utilisées jusqu’à présent. Le tableau a cette fois-ci 3 dimensions: la hauteur, la largeur et le canal de couleur. Ici notre image est constituée de 4 images à 2 dimensions, correspondant au canal rouge (<code class="docutils literal notranslate"><span class="pre">img_cells[:,:,0]</span></code>), au canal vert (<code class="docutils literal notranslate"><span class="pre">img_cells[:,:,1]</span></code>), au canal bleu
(<code class="docutils literal notranslate"><span class="pre">img_cells[:,:,2]</span></code>) et au canal alpha (<code class="docutils literal notranslate"><span class="pre">img_cells[:,:,3]</span></code>). Voyons ces 4 canaux séparement.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span># Initialisation d&#39;une figure contenant plusieurs graphiques:
fig, (ax1, ax2, ax3, ax4) = plt.subplots(1, 4, figsize=(20,10))

ax1.imshow(img_cells[:,:,0], cmap=&#39;gray&#39;,vmin = 0, vmax = 255)
ax1.set_title(&#39;rouge&#39;)
ax2.imshow(img_cells[:,:,1], cmap=&#39;gray&#39;,vmin = 0, vmax = 255)
ax2.set_title(&#39;vert&#39;)
ax3.imshow(img_cells[:,:,2], cmap=&#39;gray&#39;,vmin = 0, vmax = 255)
ax3.set_title(&#39;bleu&#39;)
ax4.imshow(img_cells[:,:,3], cmap=&#39;gray&#39;,vmin = 0, vmax = 255)
ax4.set_title(&#39;alpha&#39;)
plt.show()
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_2_Cellules_6_0.png" src="../_images/notebooks_2_Cellules_6_0.png" />
</div>
</div>
</div>
<div class="section" id="Stratégie:-lire,-segmenter,-filtrage,-grouper,-compter">
<h2>Stratégie: lire, segmenter, filtrage, grouper, compter<a class="headerlink" href="#Stratégie:-lire,-segmenter,-filtrage,-grouper,-compter" title="Lien permanent vers ce titre">¶</a></h2>
<p>Pour compter automatiquement les cellules, voici l’approche que nous allons utiliser:</p>
<ul class="simple">
<li><p>Nous allons segmenter l’image en deux pour isoler le fond des cellules, mais également isoler les cellules entre elles au mieux. Nous arriverons donc à une image avec deux valeurs possibles: des pixels à 255 s’ils sont considérés comme appartenants à une cellule, et les autres à 0.</p></li>
<li><p>Nous allons identifier les groupes de pixels correspondants à une même cellule.</p></li>
<li><p>Nous allons compter le nombre de cellules (le nombre de groupes de pixels à 255).</p></li>
</ul>
<div class="section" id="Lire">
<h3>Lire<a class="headerlink" href="#Lire" title="Lien permanent vers ce titre">¶</a></h3>
<p>Pour différencier les pixels du fond des pixels des cellules, le motif de l’image pourrait être utilisé, mais il y a plus simple. L’intensité lumineuse suffira et c’est ce que nous utiliserons. Comme le centre des cellules est le plus lumineux sur le canal vert, nous allons récupérer l’image 2D correspondante à ce canal pour faire notre segmentation.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span># Ex. 1
# ...
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_2_Cellules_9_0.png" src="../_images/notebooks_2_Cellules_9_0.png" />
</div>
</div>
</div>
<div class="section" id="Segmenter">
<h3>Segmenter<a class="headerlink" href="#Segmenter" title="Lien permanent vers ce titre">¶</a></h3>
<p>Nous aimerions compter le nombre de cellule dans cette image. Pour cela on va d’abord séparer les pixels correspondants à des cellules du reste. Cela est possible puisque les cellules sont plus claires que le fond. On pourra donc séléctionner un seuil et exécuter un programme pour segmenter notre image en fonction de ce seuil: Si l’intensité du pixel est supérieur au seuil alors le pixel sera considéré comme appartenant à une cellule, sinon non. Le résultat sera stocké dans une nouvelle image
appellée <code class="docutils literal notranslate"><span class="pre">image_segmentee</span></code>.</p>
<p>Le seuillage se fera en deux étapes: d’abord nous allons calculer et visualiser un histogramme qui permettra de savoir combien de fois chaque couleur apparait dans notre image. Cet histogramme nous permettra de choisir le seuil et de l’appliquer.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span># Ex. 2
# def get_hitogramme

plt.bar(range(256),get_histogramme(img_a_segmenter))
plt.show()
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_2_Cellules_11_0.png" src="../_images/notebooks_2_Cellules_11_0.png" />
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span># Ex. 2
# def segmenter et seuil

img_segmentee = segmenter(img_a_segmenter,seuil)

plt.imshow(img_segmentee, cmap=&#39;gray&#39;,vmin = 0, vmax = 255)
plt.show()
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_2_Cellules_12_0.png" src="../_images/notebooks_2_Cellules_12_0.png" />
</div>
</div>
</div>
<div class="section" id="Filtrage">
<h3>Filtrage<a class="headerlink" href="#Filtrage" title="Lien permanent vers ce titre">¶</a></h3>
<p>Comme vous pouvez probablement le voir, il n’est pas possible de trouver un seuil qui permette d’isoler proprement le noyau des cellules du fond. Or pour compter les cellules c’est nécessaire de le faire, car nous serons amenés à compter les groupes de pixels à 1 qui sont connectés. Pour résoudre le problème nous allons filtrer notre image de départ, comme si nous souhaitions le voir à travers de lunettes pleines de buée. En floutant notre image, les pixels de forte intensité qui sont isolés
disparaitront.</p>
<p>De manière mathématique, le floutage n’est rien d’autre qu’une moyenne: je transforme l’intensité lumineuse de chaque pixel en la moyenne de l’insensité lumineuse de ce pixel et de ses voisins.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span># filtrage
def readPixel(img,x,y):
    if x &gt;=0 and y &gt;= 0 and x &lt;= img.shape[1]-1 and y &lt;= img.shape[0]-1:
        return img[y,x]
    else:
        return 0

# Ex. 3
# def filtre
# img_filtree = ...
# img_segmentee = ...

plt.imshow(img_filtree, cmap=&#39;gray&#39;,vmin = 0, vmax = 255)
plt.imshow(img_segmentee, cmap=&#39;gray&#39;,vmin = 0, vmax = 255)
plt.show()
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_2_Cellules_14_0.png" src="../_images/notebooks_2_Cellules_14_0.png" />
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_2_Cellules_14_1.png" src="../_images/notebooks_2_Cellules_14_1.png" />
</div>
</div>
</div>
<div class="section" id="Grouper">
<h3>Grouper<a class="headerlink" href="#Grouper" title="Lien permanent vers ce titre">¶</a></h3>
<p>A présent nous devrions avoir deux noyaux qui sont mis en évidence dans notre image <code class="docutils literal notranslate"><span class="pre">img_segmentee</span></code>. Pour compter ces noyaux il va falloir être capable de faire reconnaitre à l’ordinateur que tous les pixels blancs du premier noyaux sont connectés entre eux, et qu’ils ne sont pas connectés à ceux du deuxième noyau.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span># Ex. 4
# img_group = ...
# init. img_group


# Visualisation de l&#39;image groupe: ici la valeur en elle même n&#39;a que peu d&#39;importance,
# ce qui est important est de savoir quelles valeurs sont différentes ou identiques
# pour cela nous allons utiliser une fonction qui permet d&#39;attribuer une couleur aléatoire
# à chaque valeur. Ainsi 0 pourrait être rouge, 1 jaune, 2 bleu... plutôt que rouge, rouge un peu plus foncé...
import matplotlib
cmap_rand = matplotlib.colors.ListedColormap(np.random.rand( 500,3))
plt.figure(figsize = (10,10))
plt.imshow(img_group, cmap_rand)
plt.show()
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_2_Cellules_16_0.png" src="../_images/notebooks_2_Cellules_16_0.png" />
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span># Ex. 4
# def change_image_where_to
# expand numbers in img_group

# Visualisation de l&#39;image finale
plt.figure(figsize = (10,10))
plt.imshow(img_group, cmap_rand)
plt.show()
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_2_Cellules_17_0.png" src="../_images/notebooks_2_Cellules_17_0.png" />
</div>
</div>
</div>
<div class="section" id="Compter">
<h3>Compter<a class="headerlink" href="#Compter" title="Lien permanent vers ce titre">¶</a></h3>
<p>Chaque pixel est identifié maintenant avec une valeur correspondant à un identifiant de groupe. Et chaque cellule correspond comme on le voit dans la visualisation précédente à un seul groupe. Pour compter le nombre de cellule, il ne nous reste plus qu’à identifier combien d’identifiants de groupe différents il y a.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span># Ex. 5
# def getSetFromImageGroupe
# list_group = ...
# enleve -1 de la liste

print(&quot;Il y a &quot;+str(len(list_group))+ &quot; cellules dans l&#39;image&quot;)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Il y a 2 cellules dans l&#39;image
</pre></div></div>
</div>
</div>
</div>
<div class="section" id="Elements-connectés---version-avancée">
<h2>Elements connectés - version avancée<a class="headerlink" href="#Elements-connectés---version-avancée" title="Lien permanent vers ce titre">¶</a></h2>
<p>Alors que la solution utilisée précédemment est intuitive, elle n’est absolument pas efficace: dans le pire des cas le programme devra passer à travers toute l’image et cela pour chaque pixel (complexité de O(N^2)). Vous pouvez tester les limites de cette approche en appliquant ce programme non plus à une section de l’image de 100x100 mais à l’image de départ et vous verrez le temps que cela prend…</p>
<p>Heureusement il y a beaucoup plus efficace. Mais qui dit plus efficace dit aussi souvent moins lisible. La stratégie pour faire plus rapidement sera la suivante : + On définit un état pour chacun de nos pixels comme ayant été visité ou non. Au début on considère qu’aucun pixel n’a été visité. On définira également un identifiant de groupe pour chaque pixel. Les pixels du premier groupe trouvé auront l’identifiant 1, le deuxième 2… + On commence à visiter l’image en prenant le premier pixel à
255. On retient que ce pixel a été visité en changeant son état. On retient également que ce pixel appartient au groupe 1. On lance alors une fonction <code class="docutils literal notranslate"><span class="pre">propage_groupe</span></code> qui se propage à tous les voisins qui sont à 255 et qui n’ont pas encore été visités. La fonction met définit le groupe de chaque voisin visité, le marque comme visité, et se propage à tous leurs voisins qui sont à 255 et qui n’ont pas été visités. De cette manière, les groupes sont identifiés les uns après les autres.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[11]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span>import sys
sys.setrecursionlimit(1500)

def propage_groupe_general(img,visit,group,x, y,groupe_c):
    visit[y,x] = 1 # marque pixel comme visité
    group[y,x] = groupe_c # retien sotn groupe

    if x-1 &gt;= 0 and visit[y,x-1] == 0 and img[y,x-1] == 255:
        propage_groupe_general(img,visit,group,x-1,y,groupe_c)
    if x+1 &lt; img.shape[1] and visit[y,x+1] == 0 and img[y,x+1] == 255:
        propage_groupe_general(img,visit,group,x+1,y,groupe_c)
    if y-1 &gt;= 0 and visit[y-1,x] == 0 and img[y-1,x] == 255:
        propage_groupe_general(img,visit,group,x,y-1,groupe_c)
    if y+1 &lt; img.shape[0] and visit[y+1,x] == 0 and img[y+1,x] == 255:
        propage_groupe_general(img,visit,group,x,y+1,groupe_c)

def connected_components(img_threshold):
    # défini deux variables par pixel:
    # une pour savoir si un pixel a été visité par l&#39;algorithme.
    # 0 pour &quot;pas visité&quot; et 1 pour visité
    visited_p = np.zeros(img_threshold.shape)
    # un autre pour savoir à quel groupe le pixel a été lié
    groupe_p = -np.ones(img_threshold.shape)

    # le premier pixel à 255 sera lié au groupe 1, ainsi que tous les pixels à 255
    # qui lui sont voisins, ainsi que tous les pixels à 255 qui sont voisins et voisins...
    # puisque le premier pixel et un voisin de son voisin, on utilise la variable vitite
    # pour ne pas faire un programme qui ne finit jamais. On propage ainsi le groupe seulement
    # sur les voisins qui n&#39;ont pas été encore visités.
    groupe_courant = 1
    for y in range(img_threshold.shape[0]):
        for x in range(img_threshold.shape[1]):
            # si mon pixel est à 255 et qu&#39;il n&#39;a pas été visité
            if visited_p[y,x] == 0 and img_threshold[y,x] == 255:
                # alors on le lie au groupe groupe_courant ainsi que tous ses voisins de
                # manière réccurrente.
                propage_groupe_general(img_threshold,visited_p,groupe_p,x,y,groupe_courant)
                # on liera le prochain pixel à 255 pas encore visité à un autre groupe
                groupe_courant += 1

    return groupe_courant, groupe_p

# trouve les cellules
nb_groupes, image_groupe = connected_components(img_segmentee)
plt.figure(figsize = (40,40))
plt.imshow(image_groupe, cmap_rand)
plt.show()

# compte les cellules
list_group = getSetFromImageGroupe(image_groupe)
list_group.remove(-1)
print(&quot;Il y a &quot;+str(len(list_group))+ &quot; cellules dans l&#39;image&quot;)

</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/notebooks_2_Cellules_21_0.png" src="../_images/notebooks_2_Cellules_21_0.png" />
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Il y a 2 cellules dans l&#39;image
</pre></div></div>
</div>
</div>
<div class="section" id="Alternatives">
<h2>Alternatives<a class="headerlink" href="#Alternatives" title="Lien permanent vers ce titre">¶</a></h2>
<p>Aurait-il été possible de faire sans filtrage ?</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span>
</pre></div>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="HistoireDeBugs.html" class="btn btn-neutral float-left" title="Histoire de bugs" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Précédent</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, adame.

    </p>
  </div>
    
    
    
    Compilé avec <a href="https://www.sphinx-doc.org/">Sphinx</a> en utilisant un
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">thème</a>
    
    fourni par <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>